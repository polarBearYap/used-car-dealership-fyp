import numpy as np
import pandas as pd
import matplotlib.cm as cm
import matplotlib.pyplot as plt
from scipy import stats as scipy_stats
from shap.plots import colors as shap_colors
import plotly.express as px

def prettify_feature_labels(feature_names, feature_label_names):
    """
    Rename the feature names to look nicer in plots.

    Parameters
    ----------
    feature_names: list
        List containing the feature names before renaming.
    feature_label_names: dict
        Dictionary where its key and value represents the feature names before and after renaming.

    Returns
    -------
    new_feature_names: list
        List containing the feature names after renaming.
    """
    new_feature_names = []

    for feature_name in feature_names:
        added = False
        for feature_label_name in feature_label_names.keys():
            if feature_label_name in feature_name:
                new_feature_name = feature_name.replace(feature_label_name, 
                                                        feature_label_names[feature_label_name])
                new_feature_names.append(new_feature_name)
                added = True
                break
        if not added:
            new_feature_names.append(feature_name)

    return new_feature_names

def get_shap_color_scale(cmap):
    """
    The color scale construction in Matplotlib library and Plotly library is different. Thus,
    this function is used to convert the default Matplotlib color scale used SHAP's author into 
    the format that the Plotly can understand.

    Parameters
    ----------
    cmap: matplotlib.colors.LinearSegmentedColormap
        The default colour scale used by SHAP's visualization is in shap.plots.colors.red_blue 

    Returns
    -------
    color_scale: pandas.core.series.Series
        The list containing the 200 hex colors codes. The whole list represent a continuous color scale.
    """
    data_to_color_mapper = cm.ScalarMappable(norm=cm.colors.Normalize(0, 1), 
                                             cmap=cmap)

    # Get the pre-computed color RGBA values
    c_vals = np.linspace(0, 1, num=200, dtype=np.float64)
    shap_color_vals = data_to_color_mapper.to_rgba(c_vals, bytes=True)
    shap_color_vals = pd.DataFrame(shap_color_vals, columns=['red', 'green', 'blue', 'alpha'])

    # Convert RGBA values to Hex values
    # Source: https://www.educative.io/edpresso/how-to-convert-hex-to-rgb-and-rgb-to-hex-in-python
    def rgb_to_hex_vec(r, g, b):
        return ('#{:02x}{:02x}{:02x}').format(r, g, b)

    return shap_color_vals.apply(lambda row: rgb_to_hex_vec(r = row['red'], 
                                                            g = row['green'], 
                                                            b = row['blue']), axis=1)

def shap_api_beeswarm_plot(features, shap_values):
    """
    Construct and display the beeswarm plot using matplotlib library. 
    The code is directly extracted from SHAP library.
    Comments are added so that the author can easily convert the plot's logic to the Plotly syntax.
    The plot is also used to compare with the plot generated by Plotly.

    Parameters
    ----------
    features: pandas.core.frame.DataFrame
        The features that used to calculate the SHAP values.
    shap_values: np.ndarray
        SHAP values computed from the explainer.

    Returns
    -------
    
    """

    assert features.shape == shap_values.shape, "Feature's shape and SHAP value's shape must be the same."

    # Plot's parameters
    labels = {
        'VALUE': "SHAP value (impact on model output)",
    }
    alpha=1
    axis_color="#333333"
    cmap=shap_colors.red_blue
    color = shap_colors.blue_rgb
    max_display = 20
    row_height = 0.4

    # Used to label y axis
    feature_names = features.columns
    # feature index to category flag
    idx2cat = features.dtypes.astype(str).isin(["object", "category"]).tolist()
    # Extract raw values from `features`, discard the columns' information
    features = features.values
    # Get the top `max_display` features with highest absolute shap values to display
    feature_order = np.argsort(np.sum(np.abs(shap_values), axis=0))
    feature_order = feature_order[-min(max_display, len(feature_order)):]

    for pos, i in enumerate(feature_order):
        # Draw a horizontal line, set linewidth to 0.5, draw the line before the scatterplot
        # plt.axhline(y=pos, color="#cccccc", lw=0.5, dashes=(1, 5), zorder=-1)

        # Calculate the beeswarm values
        shaps = shap_values[:, i]
        values = None if features is None else features[:, i]
        inds = np.arange(len(shaps))
        np.random.shuffle(inds)
        if values is not None:
            values = values[inds]
        shaps = shaps[inds]
        colored_feature = True
        try:
            if idx2cat is not None and idx2cat[i]: # check categorical feature
                colored_feature = False
            else:
                values = np.array(values, dtype=np.float64)  # make sure this can be numeric
        except:
            colored_feature = False
        N = len(shaps)
        nbins = 100
        quant = np.round(nbins * (shaps - np.min(shaps)) / (np.max(shaps) - np.min(shaps) + 1e-8))
        inds = np.argsort(quant + np.random.randn(N) * 1e-6)
        layer = 0
        last_bin = -1
        ys = np.zeros(N)
        for ind in inds:
            if quant[ind] != last_bin:
                layer = 0
            ys[ind] = np.ceil(layer / 2) * ((layer % 2) * 2 - 1)
            layer += 1
            last_bin = quant[ind]
        ys *= 0.9 * (row_height / np.max(ys + 1))

        if features is not None and colored_feature:
            # trim the color range, but prevent the color range from collapsing
            vmin = np.nanpercentile(values, 5)
            vmax = np.nanpercentile(values, 95)
            if vmin == vmax:
                vmin = np.nanpercentile(values, 1)
                vmax = np.nanpercentile(values, 99)
                if vmin == vmax:
                    vmin = np.min(values)
                    vmax = np.max(values)
            if vmin > vmax: # fixes rare numerical precision issues
                vmin = vmax
    
            # Plot the nan values in the interaction feature as grey
            nan_mask = np.isnan(values)
            # plt.scatter(shaps[nan_mask], pos + ys[nan_mask], color="#777777", vmin=vmin,
            #            vmax=vmax, s=16, alpha=alpha, linewidth=0,
            #            zorder=3, rasterized=len(shaps) > 500)

            # Plot the non-nan values colored by the trimmed feature value
            cvals = values[np.invert(nan_mask)].astype(np.float64)
            cvals_imp = cvals.copy()
            cvals_imp[np.isnan(cvals)] = (vmin + vmax) / 2.0
            # Ensure all the cvals lie between vmin and vmax
            cvals[cvals_imp > vmax] = vmax
            cvals[cvals_imp < vmin] = vmin

            """
            --------------
            Colour map
            --------------
            min and vmax are used in conjunction with the default norm to map the color array c to the cmap.
            Calling cmap(cvals) will return an array of RGBA (Red, Green, Blue, Alpha) values. These parameters
            are used to assign the colours based on the magnitude of the .

            --------------
            Marker
            --------------
            Set the marker size to s ** 2, and remove the marker's border line

            --------------
            Rasterization
            --------------
            Rasterization converts vector graphics into a raster image (pixels) and can speed up rendering and 
            produce smaller files for large data sets. But rasterization comes at the cost of a fixed resolution.
            """
            plt.scatter(shaps[np.invert(nan_mask)], pos + ys[np.invert(nan_mask)],
                       cmap=cmap, vmin=vmin, vmax=vmax, s=16,
                       c=cvals, alpha=alpha, linewidth=0,
                       zorder=3, rasterized=len(shaps) > 500)
        else:
            plt.scatter(shaps, pos + ys, s=16, alpha=alpha, linewidth=0, zorder=3,
                       color=color if colored_feature else "#777777", rasterized=len(shaps) > 500)
        
    # Draw the color bar
        # The ScalarMappable applies data normalization before returning RGBA colors from the given colormap.
    m = cm.ScalarMappable(cmap=cmap)
        # Set the value array from array-like A.
    m.set_array([0, 1])
        # Increase the length of color bar by setting a low aspect value
    cb = plt.colorbar(m, ticks=[0, 1], aspect=100)
    cb.set_ticklabels(['Low', 'High'])
        # Set the labelpad to negative to move the label closer to the color bar
    cb.set_label('Feature value', size=12, labelpad=-5)
        # Hide all ticks by setting length to zero
    cb.ax.tick_params(labelsize=11, length=0)
    cb.set_alpha(1)
        # Remove the outline surrounding the color bar
    cb.outline.set_visible(False)
        # Provide top and bottom padding to the color bar
        # bbox = cb.ax.get_window_extent().transformed(plt.gcf().dpi_scale_trans.inverted())
        # cb.ax.set_aspect((bbox.height - 0.9) * 20)

    # Plot configuration

    # Plot size
    plt.gcf().set_size_inches(8, len(feature_order) * row_height + 1.5)

    # Ticks' positions
    plt.gca().xaxis.set_ticks_position('bottom')
    plt.gca().yaxis.set_ticks_position('none')

    # Tick labels
    y_tick_labels = [feature_names[i] for i in feature_order]
    plt.yticks(range(len(y_tick_labels)), y_tick_labels, fontsize=13)

    # Tick colors
        # Set the tick color and the tick label color to lighter dark colour
    plt.gca().tick_params(color=axis_color, labelcolor=axis_color)

    # Tick's other parameters
    plt.gca().tick_params('x', labelsize=11)
    # plt.gca().tick_params('y', length=20, width=0.5, which='major')

    # Plot's outline borders
    plt.gca().spines['right'].set_visible(False)
    plt.gca().spines['top'].set_visible(False)
    plt.gca().spines['left'].set_visible(False)

    # Axis labels
    plt.xlabel(labels['VALUE'], fontsize=13)

    # Axis boundaries
    plt.ylim(-1, len(feature_order))

    # Draw lines
        # Add vertical line at x=0 as the reference point
        # Set zorder to smaller value to draw behind the scatter plot
    plt.axvline(x=0, color="#999999", zorder=-1)

    plt.show()

def get_beeswarm_plot_data(features, shap_values):
    """
    Prepare the beeswarm plot data to be displayed by Plotly later.
    Plotly library expects different data structure as compared to Matplotlib.
    
    Parameters
    ----------
    features: pandas.core.frame.DataFrame
        The features that used to calculate the SHAP values.
    shap_values: np.ndarray
        SHAP values computed from the explainer.

    Returns
    -------
    pd.DataFrame(plot_data): pandas.core.frame.DataFrame
        The preprocessed data used by Ploty to construct beeswarm plot
    y_tick_labels: list
        The list containing the tick labels for y-axis.
    """
    # Accumulate the values into arrays before plotting
    plot_data = {
        'shap_values': np.array([], dtype=np.float64),
        'y_locations': np.array([], dtype=np.float64),
        'feature_values': np.array([], dtype=np.float64),
        'color_values': np.array([], dtype=np.float64)
    }

    # Plot's parameters
    max_display = 20
    row_height = 0.4

    # Used to label y axis
    feature_names = features.columns
    # feature index to category flag
    # Extract raw values from `features`, discard the columns' information
    features = features.values
    # Get the top `max_display` features with highest absolute shap values to display
    feature_order = np.argsort(np.sum(np.abs(shap_values), axis=0))
    feature_order = feature_order[-min(max_display, len(feature_order)):]

    for pos, i in enumerate(feature_order):
        # Draw a horizontal line, set linewidth to 0.5, draw the line before the scatterplot
        # plt.axhline(y=pos, color="#cccccc", lw=0.5, dashes=(1, 5), zorder=-1)

        # Calculate the beeswarm values
        shaps = shap_values[:, i]
        values = features[:, i]
        inds = np.arange(len(shaps))
        np.random.shuffle(inds)
        values = values[inds]
        shaps = shaps[inds]
        values = np.array(values, dtype=np.float64)  # make sure this can be numeric
        N = len(shaps)
        nbins = 100
        quant = np.round(nbins * (shaps - np.min(shaps)) / (np.max(shaps) - np.min(shaps) + 1e-8))
        inds = np.argsort(quant + np.random.randn(N) * 1e-6)
        layer = 0
        last_bin = -1
        ys = np.zeros(N)
        for ind in inds:
            if quant[ind] != last_bin:
                layer = 0
            ys[ind] = np.ceil(layer / 2) * ((layer % 2) * 2 - 1)
            layer += 1
            last_bin = quant[ind]
        ys *= 0.9 * (row_height / np.max(ys + 1))

        # trim the color range, but prevent the color range from collapsing
        vmin = np.nanpercentile(values, 5)
        vmax = np.nanpercentile(values, 95)
        if vmin == vmax:
            vmin = np.nanpercentile(values, 1)
            vmax = np.nanpercentile(values, 99)
            if vmin == vmax:
                vmin = np.min(values)
                vmax = np.max(values)

        if vmin > vmax: # fixes rare numerical precision issues
            vmin = vmax

        # Plot the nan values in the interaction feature as grey
        nan_mask = np.isnan(values)
        # plt.scatter(shaps[nan_mask], pos + ys[nan_mask], color="#777777", vmin=vmin,
        #            vmax=vmax, s=16, alpha=alpha, linewidth=0,
        #            zorder=3, rasterized=len(shaps) > 500)

        # Plot the non-nan values colored by the trimmed feature value
        cvals = values[np.invert(nan_mask)].astype(np.float64)
        cvals_imp = cvals.copy()
        cvals_imp[np.isnan(cvals)] = (vmin + vmax) / 2.0
        # Ensure all the cvals lie between vmin and vmax
        cvals[cvals_imp > vmax] = vmax
        cvals[cvals_imp < vmin] = vmin

        plot_data['shap_values'] = np.append(plot_data['shap_values'], 
                                             shaps[np.invert(nan_mask)])
        plot_data['y_locations'] = np.append(plot_data['y_locations'], 
                                            pos + ys[np.invert(nan_mask)])
        plot_data['feature_values'] = np.append(plot_data['feature_values'], values[np.invert(nan_mask)])
        color_val_scaler = cm.colors.Normalize(vmin, vmax)
        def normalize_color_val_vec(cval):
            return color_val_scaler(cval)
        cvals = np.vectorize(normalize_color_val_vec)(cvals)
        plot_data['color_values'] = np.append(plot_data['color_values'], cvals)

    y_tick_labels = [feature_names[i] for i in feature_order]

    return pd.DataFrame(plot_data), y_tick_labels

def plot_dataman_bar_plot(features, shap_values):
    """
    Construct and display the feature importance bar plot using matplotlib library. 
    The code is extracted from a notebook authored by Dr. Dataman.
    The source code can be found at https://github.com/dataman-git/codes_for_articles/blob/master/Explain%20your%20model%20with%20the%20SHAP%20values%20for%20article.ipynb
    Comments are added so that the author can easily convert the plot's logic to the Plotly syntax.
    The plot is also used to compare with the plot generated by Plotly.

    Parameters
    ----------
    features: pandas.core.frame.DataFrame
        The features that used to calculate the SHAP values.
    shap_values: np.ndarray
        SHAP values computed from the explainer.

    Returns
    -------
    
    """

    axis_color="#333333"

    shap_color_scale = get_shap_color_scale(shap_colors.red_blue).tolist()
    
    # Get the top `max_display` features with highest absolute shap values to display
    max_display = 20
    row_height = 0.4
    feature_names = features.columns
    feature_order = np.argsort(np.sum(np.abs(shap_values), axis=0))
    feature_order = feature_order[-min(max_display, len(feature_order)):]
    
    features = features.iloc[:, feature_order].copy().reset_index(drop=True)
    shap_values = pd.DataFrame(shap_values).iloc[:, feature_order].copy().reset_index(drop=True)
    
    feature_list = shap_values.columns
    features.columns = feature_list
        
    # Determine the correlation in order to plot with different colors
    corr_list = []
    for i in feature_list:
        b = np.corrcoef(shap_values[i], features[i])[1][0]
        corr_list.append(b)
    corr_df = pd.concat([pd.Series(feature_list), pd.Series(corr_list)], axis=1).fillna(0)
    # Make a data frame. Column 1 is the feature, and Column 2 is the correlation coefficient
    corr_df.columns  = ['Variable', 'Corr']
    corr_df['Sign'] = np.where(corr_df['Corr'] > 0, shap_color_scale[-1], shap_color_scale[0])
    
    # Plot it
    shap_abs = np.abs(shap_values)
    k = pd.DataFrame(shap_abs.mean()).reset_index()
    k.columns = ['Variable','SHAP_abs']
    k2 = k.merge(corr_df, left_on = 'Variable', right_on='Variable', how='inner')
    k2 = k2.sort_values(by='SHAP_abs',ascending = True)
    colorlist = k2['Sign']
    ax = k2.plot.barh(x='Variable',y='SHAP_abs', color = colorlist, width = 0.75,
                      figsize=(8, len(feature_order) * row_height + 1.5), legend=False)
    
    
    # pl.barh(y_pos, global_shap_values[feature_inds], 0.7, align='center', color = colorlist)
    
    ax.set_xlabel('mean(|SHAP value|) (average impact on model output magnitude)', fontsize=13)
    ax.set_ylabel(None)
    
    # Additional plot settings
    ax.spines['right'].set_visible(False)
    ax.spines['top'].set_visible(False)
    ax.spines['left'].set_visible(False)
    ax.axvline(x=0, color="#999999", zorder=-1)
    ax.set_ylim(-1, len(feature_order))
    ax.tick_params('x', labelsize=11)
    ax.tick_params(color=axis_color, labelcolor=axis_color)
    ax.xaxis.set_ticks_position('bottom')
    ax.yaxis.set_ticks_position('none')
    y_tick_labels = [feature_names[i] for i in feature_order]
    ax.set_yticks(range(len(y_tick_labels)), y_tick_labels, fontsize=13)

def get_feature_importance_plot_data(features, shap_values):
    """
    Prepare the feature importance bar plot data to be displayed by Plotly later.
    Plotly library expects different data structure as compared to Matplotlib.
    
    Parameters
    ----------
    features: pandas.core.frame.DataFrame
        The features that used to calculate the SHAP values.
    shap_values: np.ndarray
        SHAP values computed from the explainer.

    Returns
    -------
    fi_df: pandas.core.frame.DataFrame
        The preprocessed data used by Ploty to construct feature importance bar plot
    """

    shap_color_scale = get_shap_color_scale(shap_colors.red_blue).tolist()

    # Get the top `max_display` features with highest absolute shap values to display
    max_display = 20
    feature_names = features.columns
    feature_order = np.argsort(np.sum(np.abs(shap_values), axis=0))
    feature_order = feature_order[-min(max_display, len(feature_order)):]

    features = features.iloc[:, feature_order].copy().reset_index(drop=True)
    shap_values = pd.DataFrame(shap_values).iloc[:, feature_order].copy().reset_index(drop=True)

    feature_list = shap_values.columns
    features.columns = feature_list

    # Determine the correlation in order to plot with different colors
    corr_list = []
    for i in feature_list:
        b = np.corrcoef(shap_values[i], features[i])[1][0]
        corr_list.append(b)
    corr_df = pd.concat([pd.Series(feature_list), pd.Series(corr_list)], axis=1).fillna(0)
    # Make a data frame. Column 1 is the feature, and Column 2 is the correlation coefficient
    corr_df.columns  = ['Variable', 'Corr']
    corr_df['Sign'] = np.where(corr_df['Corr'] > 0, shap_color_scale[-1], shap_color_scale[0])

    shap_abs = np.abs(shap_values)
    fi_df = pd.DataFrame(shap_abs.mean()).reset_index()
    fi_df.columns = ['Variable','SHAP_abs']
    fi_df = fi_df.merge(corr_df, left_on = 'Variable', right_on='Variable', how='inner')
    fi_df = fi_df.sort_values(by='SHAP_abs',ascending = True)
    fi_df['Variable'] = fi_df['Variable'].apply(lambda idx : feature_names[idx])

    return fi_df

def get_shap_loss_plot_data(features, shap_loss_values, shap_loss_type, plot = False):
    """
    Prepare the SHAP loss bar plot data to be displayed by Plotly later.
    Plotly library expects different data structure as compared to Matplotlib.
    
    Parameters
    ----------
    features: pandas.core.frame.DataFrame
        The features that used to calculate the SHAP values.
    shap_values: np.ndarray
        SHAP values computed from the explainer.
    shap_loss_type: str ('positive', 'negative')
        The type of shap loss.
    plot: bool
        If the plot is set to True, then display the plot using Pandas API.

    Returns
    -------
    plotly_plot_data: pandas.core.frame.DataFrame
        The preprocessed data used by Ploty to construct SHAP loss bar plot
    """

    assert shap_loss_type in ('positive', 'negative'), 'SHAP loss type\'s values must be either "positive" or "negative"'

    shap_loss_values = pd.DataFrame(shap_loss_values, columns = features.columns)

    if shap_loss_type == 'positive':
        shap_loss_values_summed = shap_loss_values.apply(lambda col: col[col >= 0.0].sum(), axis=0)
    else:
        shap_loss_values_summed = shap_loss_values.apply(lambda col: col[col < 0.0].sum(), axis=0)

    max_display = 20

    feature_order = np.argsort(shap_loss_values_summed, axis=0)

    if shap_loss_type == 'positive':
        ascending = False
    elif shap_loss_type == 'negative':
        ascending = True

    shap_loss_values_summed.sort_values(axis=0, ascending=ascending, inplace=True)
    plot_data = shap_loss_values_summed[:min(max_display, len(feature_order))]

    if shap_loss_type == 'positive':
        plot_data = plot_data.iloc[::-1]
    
    if plot:
        plot_data.plot.bar(fontsize=14, figsize=(10, 8))

    plotly_plot_data = pd.DataFrame(zip(plot_data.index, plot_data.values), columns=['feature', 'shap_value'])

    return plotly_plot_data

def plot_shap_monitoring(feature_name, shap_values_list, features_list, feature_names):
    """ Create a SHAP monitoring plot.
    
    A SHAP monitoring plot is meant to display the behavior of a model
    over time. Often the shap_values given to this plot explain the loss
    of a model, so changes in a feature's impact on the model's loss over
    time can help in monitoring the model's performance.
    Parameters
    ----------
    feature_name : str
        Name of the feature to plot.
    shap_values_list : list of numpy.array
        List containing two matrices of SHAP values (# samle x # features)
    features_list : list of numpy.array or list of pandas.DataFrame
        List containing two matrices of feature values (# samle x # features)
    feature_names : list
        Names of the features (length # features)
    """
    
    assert str(type(feature_names)).endswith("'list'>"), \
           'The parameter "feature_names" must be a list.'
    
    assert str(type(shap_values_list)).endswith("'list'>"), \
           'The parameter "shap_values_list" must be a list.'
    
    assert str(type(features_list)).endswith("'list'>"), \
           'The parameter "features_list" must be a list.'
    
    assert len(shap_values_list) == 2, \
           'The "shap_values_list" list must have only 2 elements.'
    
    assert len(features_list) == 2, \
           'The "features_list" list must have only 2 elements.'
    
    for idx in range(2):
        shap_values = shap_values_list[idx]
        features = features_list[idx]
        if str(type(shap_values)).endswith("'pandas.core.frame.DataFrame'>"):
            shap_values_list[idx] = shap_values.values
        else:
            assert str(type(shap_values)).endswith("'numpy.ndarray'>"), \
                   'The "shap_values_list" list element must either be pandas Dataframe or numpy array.'
        if str(type(features)).endswith("'pandas.core.frame.DataFrame'>"):
            features_list[idx] = features.values
        else:
            assert str(type(features)).endswith("'numpy.ndarray'>"), \
                   'The "shap_values_list" list element must either be pandas Dataframe or numpy array.'

    assert shap_values_list[0].shape[1] == shap_values_list[1].shape[1], \
           'The number of columns in the "shap_values_list" do not matched.'
    
    assert features_list[0].shape[1] == features_list[1].shape[1], \
           'The number of columns in the "features_list" do not matched.'
    
    num_features = shap_values_list[0].shape[1]
    
    try:
        ind = feature_names.index(feature_name)
    except ValueError as err:
        print('The feature name is not found in "feature_names".')
        raise(err)
    
    exp_shap_vals = shap_values_list[0][:, ind]
    obs_shap_vals = shap_values_list[1][:, ind]
    
    exp_features = features_list[0][:, ind]
    obs_features = features_list[1][:, ind]
    
    xs = np.arange(len(exp_shap_vals) + len(obs_shap_vals))
    ys = np.append(exp_shap_vals, obs_shap_vals)
    features = np.append(exp_features, obs_features)
    
    pvals = []
    inc = 50
    # Start calculating t-test statistics at the observed independent group
    # instead from the exp independent group
    start_idx = exp_shap_vals.shape[0]
    
    # Generate plot
    plt.figure(figsize=(10, 3))
    
    for i in range(start_idx, len(ys)-inc, inc):
        # Perform Welch's t-test
        _, pval = scipy_stats.ttest_ind(ys[:i], ys[i:], equal_var = True)
        pvals.append(pval)
    min_pval = np.min(pvals)
    min_pval_ind = np.argmin(pvals)*inc + inc + start_idx
    
    if min_pval < 0.05 / shap_values.shape[1]:
        print(f'At {min_pval_ind}, Welch\'s t-test detects SHAP loss values\' mean difference'+\
              f' with a p-value of {min_pval:.4g}')
        plt.axvline(min_pval_ind, linestyle="dashed", color="#666666", alpha=0.2)
        
    else:
        pvals = []
        
        for i in range(start_idx, len(features)-inc, inc):
            exp_val_counts = pd.Series(features[:i]).value_counts(normalize=True).to_dict()
            
            if len(exp_val_counts) == 2 and list(exp_val_counts.keys()) == [0, 1]:
                
                obs_val_counts = pd.Series(features[i:]).value_counts(normalize=False).to_dict()
                
                for cat, freq in exp_val_counts.items():
                    if cat not in obs_val_counts.keys():
                        obs_val_counts[cat] = 0
                
                scale = sum(obs_val_counts[cat] for cat in obs_val_counts.keys())
                exp_val_counts = {cat:exp_val_counts[cat]*scale \
                                  for cat, freq in exp_val_counts.items()}

                obs_freq = [obs_val_counts[cat] for cat in sorted(obs_val_counts.keys())]
                exp_freq = [exp_val_counts[cat] for cat in sorted(exp_val_counts.keys())]
                
                # Perform Chi-squared statistics
                obs_freq = np.array(obs_freq, dtype=np.float64)
                exp_freq = np.array(exp_freq, dtype=np.float64)
                
                # Manually calculate the chi-square goodness of fit test
                # since the result sometimes not accurate
                # _, p_val = scipy_stats.chisquare(f_obs = obs_freq, f_exp = exp_freq)
                obs = np.array(obs_freq)
                exps = np.array(exp_freq)
                dividend = obs - exps
                chi2_val = np.sum(np.square(dividend) / exps)

                pval = scipy_stats.chi2.sf(chi2_val, 1)
                
                pvals.append(('chi2', pval))
            else:
                # Remove outlier
                tmp = features[:i]
                exp_feature_vals = tmp[(np.abs(scipy_stats.zscore(tmp)) < 3)].copy()

                tmp = features[i:]
                obs_feature_vals = tmp[(np.abs(scipy_stats.zscore(tmp)) < 3)].copy()
                
                # Perform Welch's t-test
                _, pval = scipy_stats.ttest_ind(exp_feature_vals, obs_feature_vals, equal_var = False)
                pvals.append(('ttest', pval))

        test_type, min_pval = sorted(pvals, key=lambda elem: elem[1], reverse=False)[0]
        min_pval_ind = np.argmin([pval for _, pval in pvals]) * inc + inc + start_idx
        
        if min_pval < 0.05:
            if test_type == 'ttest':
                print(f'At {min_pval_ind}, Welch\'s t-test detects feature values\' mean difference'+\
                      f' with a p-value of {min_pval:.4g}')
            else:
                print(f'At {min_pval_ind}, chi-squared test detects feature values\' mean difference'+\
                      f' with a p-value of {min_pval:.4g}')
            plt.axvline(min_pval_ind, linestyle="dashed", color="#666666", alpha=0.2)

    plt.scatter(xs, ys, s=10, c=features, cmap=shap_colors.red_blue)
    
    plt.xlabel("Sample index")
    plt.ylabel(feature_names[ind] + "\nSHAP value", size=11)
    plt.gca().xaxis.set_ticks_position('bottom')
    plt.gca().yaxis.set_ticks_position('left')
    plt.gca().spines['right'].set_visible(False)
    plt.gca().spines['top'].set_visible(False)
    cb = plt.colorbar()
    cb.outline.set_visible(False)
    bbox = cb.ax.get_window_extent().transformed(plt.gcf().dpi_scale_trans.inverted())
    cb.ax.set_aspect((bbox.height - 0.7) * 20)
    cb.set_label(feature_names[ind], size=13)
    plt.show()

def get_shap_monitoring_plot_data(feature_name, shap_values_list, features_list, feature_names, increment=50):
    """
    Prepare the SHAP loss monitoring plot data to be displayed by Plotly later.
    Plotly library expects different data structure as compared to Matplotlib.

    Parameters
    ----------
    feature_name : str
        Name of the feature to plot.
    shap_values_list : list of numpy.array
        List containing two matrices of SHAP values (# samle x # features)
    features_list : list of numpy.array or list of pandas.core.frame.DataFrame
        List containing two matrices of feature values (# samle x # features)
    feature_names : list
        Names of the features (length # features)
    increment: int
        The increment size of the test partition for each iteration. The default value of increment is 50 samples. 
        Increase the increment to reduce false positive and decrease the increment to reduce false negative.

    Returns
    -------
    shap_monitor_plot_data: pandas.core.frame.DataFrame
        The preprocessed data used by Ploty to construct SHAP loss monitoring plot
        
    alarm_info: dict
        Dictionary containing the description of the alarm.
        The dictrionary structure is as shown below:
        {
            'p-value': float,
            'location': int,
            'message': str, 
            'type': str ('shap_ttest' or 'feature_ttest' or 'feature_chi2')
        }
    """
    
    for idx in range(2):
        shap_values = shap_values_list[idx]
        features = features_list[idx]
        if str(type(shap_values)).endswith("'pandas.core.frame.DataFrame'>"):
            shap_values_list[idx] = shap_values.values
        if str(type(features)).endswith("'pandas.core.frame.DataFrame'>"):
            features_list[idx] = features.values

    num_features = shap_values_list[0].shape[1]

    ind = feature_names.index(feature_name)

    exp_shap_vals = shap_values_list[0][:, ind]
    obs_shap_vals = shap_values_list[1][:, ind]

    exp_features = features_list[0][:, ind]
    obs_features = features_list[1][:, ind]

    xs = np.arange(len(exp_shap_vals) + len(obs_shap_vals))
    ys = np.append(exp_shap_vals, obs_shap_vals)
    features = np.append(exp_features, obs_features)
    shap_monitor_plot_data = pd.DataFrame(xs, columns=['sample_index'])
    shap_monitor_plot_data['shap_values'] = ys
    shap_monitor_plot_data['feature_values'] = features
    # trim the color range, but prevent the color range from collapsing
    vmin = np.nanpercentile(features, 5)
    vmax = np.nanpercentile(features, 95)
    if vmin == vmax:
        vmin = np.nanpercentile(features, 1)
        vmax = np.nanpercentile(features, 99)
        if vmin == vmax:
            vmin = np.min(features)
            vmax = np.max(features)

    if vmin > vmax: # fixes rare numerical precision issues
        vmin = vmax
    color_val_scaler = cm.colors.Normalize(vmin, vmax)
    def normalize_color_val_vec(cval):
        return color_val_scaler(cval)
    cvals = np.vectorize(normalize_color_val_vec)(features)
    shap_monitor_plot_data['color_values'] = cvals

    pvals = []
    t_statistics = []
    # Start calculating t-test statistics at the observed independent group
    # instead from the exp independent group
    start_idx = exp_shap_vals.shape[0]

    alarm_info = {}

    for i in range(start_idx, len(ys)-increment, increment):
        # Perform Welch's t-test
        t_statistic, pval = scipy_stats.ttest_ind(ys[:i], ys[i:], equal_var = True)
        pvals.append(pval)
        t_statistics.append(t_statistic)
    min_pval = np.min(pvals)
    min_pval_ind = np.argmin(pvals)*increment + increment + start_idx
    min_t_statistic = t_statistics[np.argmin(pvals)]

    if min_pval < 0.05 / shap_values.shape[1]:
        alarm_info = {
            'p-value': min_pval,
            'location': min_pval_ind,
            't_stats': min_t_statistic,
            'message': f'At {min_pval_ind}, Welch\'s t-test detects SHAP loss values\' mean difference'+\
            f' with a p-value of {min_pval:.4g}', 
            'type': 'shap_ttest'
        }

    else:
        pvals = []

        for i in range(start_idx, len(features)-increment, increment):
            exp_val_counts = pd.Series(features[:i]).value_counts(normalize=True).to_dict()

            if len(exp_val_counts) == 2 and list(exp_val_counts.keys()) == [0, 1]:

                obs_val_counts = pd.Series(features[i:]).value_counts(normalize=False).to_dict()

                for cat, freq in exp_val_counts.items():
                    if cat not in obs_val_counts.keys():
                        obs_val_counts[cat] = 0

                scale = sum(obs_val_counts[cat] for cat in obs_val_counts.keys())
                exp_val_counts = {cat:exp_val_counts[cat]*scale \
                                for cat, freq in exp_val_counts.items()}

                obs_freq = [obs_val_counts[cat] for cat in sorted(obs_val_counts.keys())]
                exp_freq = [exp_val_counts[cat] for cat in sorted(exp_val_counts.keys())]

                # Perform Chi-squared statistics
                obs_freq = np.array(obs_freq, dtype=np.float64)
                exp_freq = np.array(exp_freq, dtype=np.float64)

                # Manually calculate the chi-square goodness of fit test
                # since the result sometimes not accurate
                # _, p_val = scipy_stats.chisquare(f_obs = obs_freq, f_exp = exp_freq)
                obs = np.array(obs_freq)
                exps = np.array(exp_freq)
                dividend = obs - exps
                chi2_val = np.sum(np.square(dividend) / exps)

                pval = scipy_stats.chi2.sf(chi2_val, 1)

                pvals.append(('chi2', pval))
            else:
                # Remove outlier
                tmp = features[:i]
                exp_feature_vals = tmp[(np.abs(scipy_stats.zscore(tmp)) < 3)].copy()

                tmp = features[i:]
                obs_feature_vals = tmp[(np.abs(scipy_stats.zscore(tmp)) < 3)].copy()

                # Perform Welch's t-test
                _, pval = scipy_stats.ttest_ind(exp_feature_vals, obs_feature_vals, equal_var = False)
                pvals.append(('ttest', pval))

        test_type, min_pval = sorted(pvals, key=lambda elem: elem[1], reverse=False)[0]
        min_pval_ind = np.argmin([pval for _, pval in pvals]) * increment + increment + start_idx

        if min_pval < 0.05:
            message = None
            if test_type == 'ttest':
                message = f'At {min_pval_ind}, Welch\'s t-test detects feature values\' mean difference'+\
                    f' with a p-value of {min_pval:.4g}'
                alarm_info['type'] = 'feature_ttest'
            else:
                message = f'At {min_pval_ind}, chi-squared test detects feature values\' mean difference'+\
                    f' with a p-value of {min_pval:.4g}'
                alarm_info['type'] = 'feature_chi2'
            alarm_info.update({
                'p-value': min_pval,
                'location': min_pval_ind,
                'message': message
            })

    return shap_monitor_plot_data, alarm_info

def plot_shap_monitoring_plot_plotly(feature_name, shap_values_list, features_list, 
                                     feature_names, feature_label_names, increment=50):
    """
    Construct the SHAP loss monitoring plot using Plotly.

    Parameters
    ----------
    feature_name : str
        Name of the feature to plot.
    shap_values_list : list of numpy.array
        List containing two matrices of SHAP values (# samle x # features)
    features_list : list of numpy.array or list of pandas.core.frame.DataFrame
        List containing two matrices of feature values (# samle x # features)
    feature_names : list
        Names of the features (length # features)
    feature_label_names: dict
        Dictionary where its key and value represents the feature names before and after renaming.
        Used to call `prettify_feature_labels` function.
    increment: int optional
        The increment size of the test partition for each iteration. The default value of increment is 50 samples. 
        Increase the increment to reduce false positive and decrease the increment to reduce false negative. Note
        that the increment is used in `get_shap_monitoring_plot_data` function.

    Returns
    -------
    fig: plotly.graph_objs._figure.Figure
        The Plotly Figure object.

    alarm_info: dict
        Dictionary containing the description of the alarm.
        The dictrionary structure is as shown below:
        {
            'p-value': float,
            'location': int,
            'message': str, 
            'type': str ('shap_ttest' or 'feature_ttest' or 'feature_chi2')
        }
    """

    axis_color="#333333"

    shap_color_scale = get_shap_color_scale(shap_colors.red_blue)

    shap_monitor_plot_data, alarm_info = get_shap_monitoring_plot_data(
        feature_name, 
        shap_values_list, 
        features_list, 
        feature_names, 
        increment
    )

    fig = px.scatter(shap_monitor_plot_data, color_continuous_scale = shap_color_scale,
                    x='sample_index', y='shap_values', color='color_values', 
                    labels=dict(shap_values = 'SHAP loss value', sample_index = 'Sample index')
                    )

    fig.update_layout(
        width = 800,
        height = 400,
        showlegend = False,
        paper_bgcolor='rgba(0,0,0,0)',
        plot_bgcolor='rgba(0,0,0,0)',
        xaxis = dict(
            ticks = 'outside',
            tickcolor = axis_color,
            tickfont_color = axis_color,
            showline = True,
            linewidth = 1, 
            linecolor = axis_color
        ),
        yaxis = dict(
            ticks = 'outside',
            tickcolor = axis_color,
            tickfont_color = axis_color,
            showline = True,
            linewidth = 1, 
            linecolor = axis_color, 
            range = [np.min(shap_monitor_plot_data['shap_values']) * 1.2, 
                    np.max(shap_monitor_plot_data['shap_values']) * 1.2]
        ),
        coloraxis = dict(
            colorbar_title_text = 'Feature value',
            colorbar_title_side = 'right',
            colorbar_tickmode = 'array',
            colorbar_tickvals = [np.min(shap_monitor_plot_data['color_values']), 
                                np.max(shap_monitor_plot_data['color_values'])],
            colorbar_ticktext = ['Low', 'High'],
            colorbar_thickness = 15
        )
    )

    fig.update_traces(
        customdata = shap_monitor_plot_data['feature_values'],
        hovertemplate = \
        f'<i>{prettify_feature_labels([feature_name], feature_label_names)[0]}</i>: '+
        '%{customdata:.0f}<br>'+
        '<i>Sample index</i>: %{x:.0f}<br>' +
        '<i>SHAP loss value</i>: %{y:.0f}<br>'
    )

    if len(alarm_info) > 0:
        fig.add_shape(
            type = 'line',
            x0 = alarm_info['location'], 
            y0 = np.min(shap_monitor_plot_data['shap_values']) * 1.2, 
            x1 = alarm_info['location'], 
            y1 = np.max(shap_monitor_plot_data['shap_values']) * 1.2,
            line=dict(
                color = axis_color, 
                width = 1, 
                dash = 'dot'
            ),
            opacity = 0.8
        )

    return fig, alarm_info

def plot_local_bar_plot_plotly(shap_values, features, feature_names, feature_label_names, shap_type = 'SHAP value'):
    """
    Construct the bar plot using Plotly for local explanation.

    Parameters
    ----------
    shap_values : np.ndarray of shape (number of features,)
        The shap values for the sample.
    features : np.ndarray of shape shape (number of features,)
        The features for the sample.
    feature_names : list of size (number of features,)
        List containing  the feature names.
    feature_label_names: dict
        Dictionary where its key and value represents the feature names before and after renaming.
        Used to call `prettify_feature_labels` function.
    shap_type: str optional
        Used to set the y axis labels.

    Returns
    -------
    fig: plotly.graph_objs._figure.Figure
        The Plotly Figure object.
    """

    max_display=20
    axis_color="#333333"
    shap_color_scale = get_shap_color_scale(shap_colors.red_blue).tolist()

    local_bar_plot_data_ = pd.Series(shap_values, index=feature_names)
    local_bar_plot_data_ = pd.DataFrame(zip(local_bar_plot_data_.index, local_bar_plot_data_.values), 
                                        columns=['feature_name', 'shap_value'])
    sort_idx = np.argsort(np.abs(local_bar_plot_data_['shap_value']))[::-1]

    local_bar_plot_data = local_bar_plot_data_.loc[sort_idx[:max_display], :].copy()
    local_bar_plot_data = local_bar_plot_data.reset_index(drop=True)
    remaining_shap_values = np.sum(local_bar_plot_data_.loc[sort_idx[max_display:], 'shap_value'])
    local_bar_plot_data.loc[max_display, :] = ['Other Features', remaining_shap_values]
    
    feature_names = local_bar_plot_data['feature_name'].tolist()
    feature_values = []
    for feature_name in feature_names[:-1]:
        idx = feature_names.index(feature_name)
        feature_values.append(features[idx])
    feature_values.append('Not Applicable')
    
    local_bar_plot_data.loc[:, 'feature_value'] = feature_values
    
    local_bar_plot_data['Sign'] = np.where(local_bar_plot_data['shap_value'] > 0, 
                                           shap_color_scale[-1], shap_color_scale[0])
    local_bar_plot_data = local_bar_plot_data.iloc[::-1]

    fig = px.bar(local_bar_plot_data, 
                 x='shap_value', 
                 y='feature_name', 
                 labels=dict(shap_value = shap_type, feature_name=""))

    fig.update_layout(
        width = 800,
        height = 700,
        showlegend = False,
        paper_bgcolor='rgba(0,0,0,0)',
        plot_bgcolor='rgba(0,0,0,0)',
        yaxis = dict(
            showline = True,
            linewidth = 1, 
            linecolor = axis_color,
            ticks = 'outside',
            # Set the tick color and the tick label color to lighter dark colour
            tickcolor = axis_color,
            tickfont_color = axis_color,
            tickmode = 'array',
            tickvals = list(range(len(local_bar_plot_data['feature_name']))),
            ticktext = prettify_feature_labels(local_bar_plot_data['feature_name'], 
                                               feature_label_names),
            range = [-1, local_bar_plot_data.shape[0]]
        ),
        xaxis = dict(
            # Set the tick color and the tick label color to lighter dark colour
            ticks = 'outside',
            tickcolor = axis_color,
            tickfont_color = axis_color,
            showline = True,
            linewidth = 1, 
            linecolor = axis_color
        )
    )

    fig.update_traces(
        customdata = local_bar_plot_data['feature_value'],
        hovertemplate = '<i>Feature:</i> %{y}<br>'+
        '<i>Feature value</i>: %{customdata:.0f}<br>'+
        '<i>SHAP values</i>: %{x:.0f}<br>',
        marker_color = local_bar_plot_data['Sign']
    )

    return fig

def plot_beeswarm_plot_plotly(features, shap_values, feature_label_names):
    """
    Construct the beeswarm plot using Plotly.

    Parameters
    ----------
    features: pandas.core.frame.DataFrame
        The features that used to calculate the SHAP values.
    shap_values: np.ndarray
        SHAP values computed from the explainer.
    feature_label_names: dict
        Dictionary where its key and value represents the feature names before and after renaming.
        Used to call `prettify_feature_labels` function.

    Returns
    -------
    fig: plotly.graph_objs._figure.Figure
        The Plotly Figure object.
    """

    axis_color="#333333"

    shap_color_scale = get_shap_color_scale(shap_colors.red_blue)

    beeswarm_plot_data, y_tick_labels = get_beeswarm_plot_data(features, shap_values)

    y_tick_labels = prettify_feature_labels(y_tick_labels, feature_label_names)

    fig = px.scatter(beeswarm_plot_data, color_continuous_scale = shap_color_scale,
                     x='shap_values', y='y_locations', color='color_values', 
                     labels=dict(shap_values = 'SHAP value (impact on model output)', y_locations="")
                    )

    fig.update_layout(
        width = 750,
        height = 1000,
        showlegend = False,
        paper_bgcolor='rgba(0,0,0,0)',
        plot_bgcolor='rgba(0,0,0,0)',
        xaxis = dict(
            ticks = 'outside',
            # Set the tick color and the tick label color to lighter dark colour
            tickcolor = axis_color,
            tickfont_color = axis_color,
            showline = True,
            linewidth = 1, 
            linecolor = axis_color
        ),
        yaxis = dict(
            tickmode = 'array',
            tickvals = list(range(len(y_tick_labels))),
            # Set the tick color and the tick label color to lighter dark colour
            ticktext = y_tick_labels,
            tickfont_color = axis_color,
            range = [-1, len(y_tick_labels)]
        ),
        coloraxis = dict(
            colorbar_title_text = 'Feature value',
            colorbar_title_side = 'right',
            colorbar_tickmode = 'array',
            colorbar_tickvals = [0.0, 1.0],
            colorbar_ticktext = ['Low', 'High'],
            colorbar_thickness = 15
        )
    )

    fig.update_traces(
        customdata = beeswarm_plot_data["feature_values"],
        hovertemplate = \
        '<i>Feature value</i>: %{customdata:.0f}<br>'+
        '<i>SHAP value</i>: %{x:.0f}<br>'
    )

    fig.add_shape(
        type = "line",
        x0 = 0, y0 = -1, x1 = 0, y1 = len(y_tick_labels),
        line=dict(
            color = axis_color, 
            width = 1
        ),
        opacity = 0.5
    )

    return fig

def plot_feature_importance_bar_plot_plotly(features, shap_values, feature_label_names):
    """
    Construct the feature importance bar plot using Plotly.

    Parameters
    ----------
    features: pandas.core.frame.DataFrame
        The features that used to calculate the SHAP values.
    shap_values: np.ndarray
        SHAP values computed from the explainer.
    feature_label_names: dict
        Dictionary where its key and value represents the feature names before and after renaming.
        Used to call `prettify_feature_labels` function.

    Returns
    -------
    fig: plotly.graph_objs._figure.Figure
        The Plotly Figure object.
    """

    axis_color="#333333"

    fi_plot_data = get_feature_importance_plot_data(features, shap_values)

    fig = px.bar(fi_plot_data, 
                x='SHAP_abs', 
                y='Variable', 
                orientation='h', 
                labels=dict(SHAP_abs = 'Sum of absolute SHAP values (red: positive correlation)', 
                            Variable=""))

    fig.update_layout(
        width = 800,
        height = 600,
        showlegend = False,
        paper_bgcolor='rgba(0,0,0,0)',
        plot_bgcolor='rgba(0,0,0,0)',
        xaxis = dict(
            ticks = 'outside',
            # Set the tick color and the tick label color to lighter dark colour
            tickcolor = axis_color,
            tickfont_color = axis_color,
            showline = True,
            linewidth = 1, 
            linecolor = axis_color, 
            range = [-np.max(fi_plot_data['SHAP_abs']) * 0.03, np.max(fi_plot_data['SHAP_abs']) * 1.1]
        ),
        yaxis = dict(
            # Set the tick color and the tick label color to lighter dark colour
            tickmode = 'array',
            tickcolor = axis_color,
            tickfont_color = axis_color,
            tickvals = list(range(len(fi_plot_data['Variable']))),
            ticktext = prettify_feature_labels(fi_plot_data['Variable'], feature_label_names),
            range = [-1, fi_plot_data.shape[0]]
        )
    )

    fig.add_shape(
        type = "line",
        x0 = 0, y0 = -1, x1 = 0, y1 = fi_plot_data.shape[0],
        line=dict(
            color = axis_color, 
            width = 1
        ),
        opacity = 0.5
    )

    fig.update_traces(hovertemplate = '<i>Feature:</i> %{y}<br><i>Sum of SHAP absolute values</i>: %{x:.0f}<br>')

    fig.update_traces(
        marker_color = fi_plot_data['Sign'], 
    )

    return fig

def plot_model_loss_bar_plot_plotly(features, shap_values, feature_label_names, shap_loss_type):
    """
    Construct the feature importance bar plot using Plotly.

    Parameters
    ----------
    features: pandas.core.frame.DataFrame
        The features that used to calculate the SHAP values.
    shap_values: np.ndarray
        SHAP values computed from the explainer.
    feature_label_names: dict
        Dictionary where its key and value represents the feature names before and after renaming.
        Used to call `prettify_feature_labels` function.
    shap_loss_type: str
        If the shap_loss_type is set to 'positive', then the positive SHAP loss bar plot is constructed.
        Else if the shap_loss_type is set to 'negative', then the negative SHAP loss bar plot is constructed. 

    Returns
    -------
    fig: plotly.graph_objs._figure.Figure
        The Plotly Figure object.
    """

    assert shap_loss_type in ['positive', 'negative'], 'shap_loss_type value should be either "positive" or "negative"'

    axis_color="#333333"

    plotly_plot_data = get_shap_loss_plot_data(
        features, 
        shap_values, 
        shap_loss_type = shap_loss_type, 
        plot = False
    )

    fig = px.bar(plotly_plot_data, 
                x='feature', 
                y='shap_value', 
                labels=dict(shap_value = f'Sum of {shap_loss_type.title()} SHAP loss value', feature=""))

    fig.update_layout(
        width = 800,
        height = 700,
        showlegend = False,
        paper_bgcolor='rgba(0,0,0,0)',
        plot_bgcolor='rgba(0,0,0,0)',
        xaxis = dict(
            ticks = 'outside',
            tickangle = -45,
            # Set the tick color and the tick label color to lighter dark colour
            tickcolor = axis_color,
            tickfont_color = axis_color,
            tickmode = 'array',
            tickvals = list(range(len(plotly_plot_data['feature']))),
            ticktext = prettify_feature_labels(plotly_plot_data['feature'], 
                                            feature_label_names),
            range = [-1, plotly_plot_data.shape[0]]
        ),
        yaxis = dict(
            # Set the tick color and the tick label color to lighter dark colour
            tickcolor = axis_color,
            tickfont_color = axis_color,
            showline = True,
            linewidth = 1, 
            linecolor = axis_color
        )
    )

    fig.update_traces(hovertemplate = '<i>Feature:</i> %{x}<br><i>Sum of SHAP loss values</i>: %{y:.0f}<br>')

    return fig

